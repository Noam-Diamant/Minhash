
// Generated by Cadence Genus(TM) Synthesis Solution 21.15-s080_1
// Generated on: Aug 11 2024 13:40:44 UTC (Aug 11 2024 13:40:44 UTC)

// Verification Directory fv/proj_counter 

module add_unsigned(A, B, Z);
  input [6:0] A;
  input B;
  output [6:0] Z;
  wire [6:0] A;
  wire B;
  wire [6:0] Z;
  wire n_16, n_20, n_23, n_25, n_29, n_31, n_35, n_36;
  wire n_38, n_39, n_41, n_42, n_47, n_49, n_51, n_52;
  wire n_57, n_62, n_68, n_71;
  xor g1 (Z[0], A[0], B);
  nand g2 (n_16, A[0], B);
  nand g19 (n_23, n_20, A[1]);
  nor g24 (n_39, n_29, n_25);
  nor g28 (n_47, n_35, n_31);
  nand g30 (n_38, n_36, A[2]);
  nand g32 (n_41, n_39, n_36);
  nand g40 (n_51, n_49, A[4]);
  nand g42 (n_52, n_47, n_49);
  xnor g48 (Z[1], n_20, n_57);
  xnor g50 (Z[2], n_36, n_29);
  xnor g53 (Z[3], n_62, n_25);
  xnor g55 (Z[4], n_49, n_35);
  xnor g58 (Z[5], n_68, n_31);
  xnor g60 (Z[6], n_71, n_42);
  not g63 (n_29, A[2]);
  not g64 (n_25, A[3]);
  not g65 (n_35, A[4]);
  not g66 (n_31, A[5]);
  not g67 (n_42, A[6]);
  not g68 (n_20, n_16);
  not g69 (n_57, A[1]);
  not g70 (n_36, n_23);
  not g71 (n_62, n_38);
  not g72 (n_49, n_41);
  not g73 (n_68, n_51);
  not g74 (n_71, n_52);
endmodule

module bmux_1(ctl, in_0, in_1, z);
  input ctl;
  input [6:0] in_0, in_1;
  output [6:0] z;
  wire ctl;
  wire [6:0] in_0, in_1;
  wire [6:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[6]), .data1 (in_1[6]), .z
       (z[6]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[5]), .data1 (in_1[5]), .z
       (z[5]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[4]), .data1 (in_1[4]), .z
       (z[4]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g5(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g6(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g7(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module proj_counter(index, finished_count, clk, rst_n, start);
  input clk, rst_n, start;
  output [6:0] index;
  output finished_count;
  wire clk, rst_n, start;
  wire [6:0] index;
  wire finished_count;
  wire [6:0] idx_next;
  wire count_enabled, n_36, n_38, n_39, n_40, n_42, n_44, n_46;
  wire n_48, n_50, n_52, n_54, n_56, n_57, n_58, n_59;
  wire n_60, n_61, n_62, n_70, n_72, n_73, n_74, n_76;
  wire n_77, n_78, n_96, n_108, n_109, rst_index, start_prev;
  add_unsigned add_27_67(.A (index), .B (1'b1), .Z ({n_52, n_50, n_48,
       n_46, n_44, n_42, n_40}));
  bmux_1 mux_27_38(.ctl (n_39), .in_0 (index), .in_1 ({n_52, n_50,
       n_48, n_46, n_44, n_42, n_40}), .z (idx_next));
  bmux_1 mux_out_index_46_32(.ctl (n_38), .in_0 (idx_next), .in_1
       (7'b0), .z ({n_62, n_61, n_60, n_59, n_58, n_57, n_56}));
  bmux mux_23_38(.ctl (n_54), .in_0 (1'b0), .in_1 (1'b1), .z
       (finished_count));
  not g1 (n_70, finished_count);
  and g2 (n_39, count_enabled, n_70);
  not g3 (n_36, rst_n);
  or g4 (rst_index, finished_count, n_36);
  not g5 (n_72, start_prev);
  and g6 (n_38, start, n_72);
  not g11 (n_73, n_38);
  not g15 (n_77, rst_index);
  and g16 (n_74, count_enabled, n_73);
  or g17 (n_76, n_74, n_38);
  and g18 (n_78, n_38, n_77);
  CDN_flop \out_index_reg[0] (.clk (clk), .d (n_56), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[0]));
  CDN_flop \out_index_reg[1] (.clk (clk), .d (n_57), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[1]));
  CDN_flop \out_index_reg[2] (.clk (clk), .d (n_58), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[2]));
  CDN_flop \out_index_reg[3] (.clk (clk), .d (n_59), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[3]));
  CDN_flop \out_index_reg[4] (.clk (clk), .d (n_60), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[4]));
  CDN_flop \out_index_reg[5] (.clk (clk), .d (n_61), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[5]));
  CDN_flop \out_index_reg[6] (.clk (clk), .d (n_62), .sena (n_76),
       .aclr (n_36), .apre (1'b0), .srl (rst_index), .srd (1'b0), .q
       (index[6]));
  CDN_flop count_enabled_reg(.clk (clk), .d (1'b0), .sena (1'b0), .aclr
       (n_36), .apre (1'b0), .srl (n_96), .srd (n_77), .q
       (count_enabled));
  or g32 (n_96, rst_index, n_78);
  CDN_flop start_prev_reg(.clk (clk), .d (start), .sena (1'b1), .aclr
       (n_36), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (start_prev));
  nand g8 (n_108, index[0], index[1], index[2], index[3]);
  nand g9 (n_109, index[4], index[5], index[6]);
  nor g43 (n_54, n_109, n_108);
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
