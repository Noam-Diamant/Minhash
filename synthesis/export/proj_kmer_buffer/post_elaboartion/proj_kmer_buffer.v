
// Generated by Cadence Genus(TM) Synthesis Solution 21.15-s080_1
// Generated on: Aug 11 2024 19:14:06 UTC (Aug 11 2024 19:14:06 UTC)

// Verification Directory fv/proj_kmer_buffer 

module add_unsigned(A, B, Z);
  input [3:0] A;
  input B;
  output [3:0] Z;
  wire [3:0] A;
  wire B;
  wire [3:0] Z;
  wire n_10, n_14, n_17, n_19, n_23, n_24, n_26, n_30;
  wire n_35;
  xor g1 (Z[0], A[0], B);
  nand g2 (n_10, A[0], B);
  nand g13 (n_17, n_14, A[1]);
  nand g20 (n_26, n_24, A[2]);
  xnor g25 (Z[1], n_14, n_30);
  xnor g27 (Z[2], n_24, n_23);
  xnor g30 (Z[3], n_35, n_19);
  not g33 (n_23, A[2]);
  not g34 (n_19, A[3]);
  not g35 (n_14, n_10);
  not g36 (n_30, A[1]);
  not g37 (n_24, n_17);
  not g38 (n_35, n_26);
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module bmux_1(ctl, in_0, in_1, z);
  input ctl;
  input [3:0] in_0, in_1;
  output [3:0] z;
  wire ctl;
  wire [3:0] in_0, in_1;
  wire [3:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module proj_kmer_buffer(clk, rst_n, in_data, \out_kmer[0] ,
     \out_kmer[1] , \out_kmer[2] , \out_kmer[3] , \out_kmer[4] ,
     \out_kmer[5] , \out_kmer[6] , \out_kmer[7] , \out_kmer[8] ,
     \out_kmer[9] , \out_kmer[10] , \out_kmer[11] , \out_kmer[12] ,
     \out_kmer[13] , \out_kmer[14] , \out_kmer[15] , start_over, full);
  input clk, rst_n, start_over;
  input [1:0] in_data;
  output [1:0] \out_kmer[0] , \out_kmer[1] , \out_kmer[2] ,
       \out_kmer[3] , \out_kmer[4] , \out_kmer[5] , \out_kmer[6] ,
       \out_kmer[7] , \out_kmer[8] , \out_kmer[9] , \out_kmer[10] ,
       \out_kmer[11] , \out_kmer[12] , \out_kmer[13] , \out_kmer[14] ,
       \out_kmer[15] ;
  output full;
  wire clk, rst_n, start_over;
  wire [1:0] in_data;
  wire [1:0] \out_kmer[0] , \out_kmer[1] , \out_kmer[2] , \out_kmer[3]
       , \out_kmer[4] , \out_kmer[5] , \out_kmer[6] , \out_kmer[7] ,
       \out_kmer[8] , \out_kmer[9] , \out_kmer[10] , \out_kmer[11] ,
       \out_kmer[12] , \out_kmer[13] , \out_kmer[14] , \out_kmer[15] ;
  wire full;
  wire [3:0] buffer_count;
  wire [3:0] buffer_count_nxt;
  wire [31:0] kmer_buffer_nxt;
  wire n_80, n_82, n_83, n_84, n_85, n_86, n_206;
  add_unsigned add_23_44(.A (buffer_count), .B (1'b1), .Z
       (buffer_count_nxt));
  bmux mux_26_40(.ctl (n_82), .in_0 (1'b0), .in_1 (1'b1), .z (full));
  bmux_1 mux_buffer_count_57_22(.ctl (full), .in_0 (buffer_count_nxt),
       .in_1 (buffer_count), .z ({n_86, n_85, n_84, n_83}));
  not g1 (n_80, rst_n);
  CDN_flop \kmer_buffer_reg[0] (.clk (clk), .d (in_data[0]), .sena
       (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over), .srd
       (1'b0), .q (\out_kmer[0] [0]));
  CDN_flop \kmer_buffer_reg[1] (.clk (clk), .d (in_data[1]), .sena
       (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over), .srd
       (1'b0), .q (\out_kmer[0] [1]));
  CDN_flop \kmer_buffer_reg[2] (.clk (clk), .d (\out_kmer[0] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[1] [0]));
  CDN_flop \kmer_buffer_reg[3] (.clk (clk), .d (\out_kmer[1] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[1] [1]));
  CDN_flop \kmer_buffer_reg[4] (.clk (clk), .d (\out_kmer[1] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[2] [0]));
  CDN_flop \kmer_buffer_reg[5] (.clk (clk), .d (\out_kmer[2] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[2] [1]));
  CDN_flop \kmer_buffer_reg[6] (.clk (clk), .d (\out_kmer[2] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[3] [0]));
  CDN_flop \kmer_buffer_reg[7] (.clk (clk), .d (\out_kmer[3] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[3] [1]));
  CDN_flop \kmer_buffer_reg[8] (.clk (clk), .d (\out_kmer[3] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[4] [0]));
  CDN_flop \kmer_buffer_reg[9] (.clk (clk), .d (\out_kmer[4] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[4] [1]));
  CDN_flop \kmer_buffer_reg[10] (.clk (clk), .d (\out_kmer[4] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[5] [0]));
  CDN_flop \kmer_buffer_reg[11] (.clk (clk), .d (\out_kmer[5] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[5] [1]));
  CDN_flop \kmer_buffer_reg[12] (.clk (clk), .d (\out_kmer[5] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[6] [0]));
  CDN_flop \kmer_buffer_reg[13] (.clk (clk), .d (\out_kmer[6] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[6] [1]));
  CDN_flop \kmer_buffer_reg[14] (.clk (clk), .d (\out_kmer[6] [1]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[7] [0]));
  CDN_flop \kmer_buffer_reg[15] (.clk (clk), .d (\out_kmer[7] [0]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[7] [1]));
  CDN_flop \kmer_buffer_reg[16] (.clk (clk), .d (kmer_buffer_nxt[16]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[8] [0]));
  CDN_flop \kmer_buffer_reg[17] (.clk (clk), .d (kmer_buffer_nxt[17]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[8] [1]));
  CDN_flop \kmer_buffer_reg[18] (.clk (clk), .d (kmer_buffer_nxt[18]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[9] [0]));
  CDN_flop \kmer_buffer_reg[19] (.clk (clk), .d (kmer_buffer_nxt[19]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[9] [1]));
  CDN_flop \kmer_buffer_reg[20] (.clk (clk), .d (kmer_buffer_nxt[20]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[10] [0]));
  CDN_flop \kmer_buffer_reg[21] (.clk (clk), .d (kmer_buffer_nxt[21]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[10] [1]));
  CDN_flop \kmer_buffer_reg[22] (.clk (clk), .d (kmer_buffer_nxt[22]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[11] [0]));
  CDN_flop \kmer_buffer_reg[23] (.clk (clk), .d (kmer_buffer_nxt[23]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[11] [1]));
  CDN_flop \kmer_buffer_reg[24] (.clk (clk), .d (kmer_buffer_nxt[24]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[12] [0]));
  CDN_flop \kmer_buffer_reg[25] (.clk (clk), .d (kmer_buffer_nxt[25]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[12] [1]));
  CDN_flop \kmer_buffer_reg[26] (.clk (clk), .d (kmer_buffer_nxt[26]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[13] [0]));
  CDN_flop \kmer_buffer_reg[27] (.clk (clk), .d (kmer_buffer_nxt[27]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[13] [1]));
  CDN_flop \kmer_buffer_reg[28] (.clk (clk), .d (kmer_buffer_nxt[28]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[14] [0]));
  CDN_flop \kmer_buffer_reg[29] (.clk (clk), .d (kmer_buffer_nxt[29]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[14] [1]));
  CDN_flop \kmer_buffer_reg[30] (.clk (clk), .d (kmer_buffer_nxt[30]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[15] [0]));
  CDN_flop \kmer_buffer_reg[31] (.clk (clk), .d (kmer_buffer_nxt[31]),
       .sena (1'b1), .aclr (n_80), .apre (1'b0), .srl (start_over),
       .srd (1'b0), .q (\out_kmer[15] [1]));
  CDN_flop \buffer_count_reg[0] (.clk (clk), .d (n_83), .sena (1'b1),
       .aclr (n_80), .apre (1'b0), .srl (start_over), .srd (1'b0), .q
       (buffer_count[0]));
  CDN_flop \buffer_count_reg[1] (.clk (clk), .d (n_84), .sena (1'b1),
       .aclr (n_80), .apre (1'b0), .srl (start_over), .srd (1'b0), .q
       (buffer_count[1]));
  CDN_flop \buffer_count_reg[2] (.clk (clk), .d (n_85), .sena (1'b1),
       .aclr (n_80), .apre (1'b0), .srl (start_over), .srd (1'b0), .q
       (buffer_count[2]));
  CDN_flop \buffer_count_reg[3] (.clk (clk), .d (n_86), .sena (1'b1),
       .aclr (n_80), .apre (1'b0), .srl (start_over), .srd (1'b0), .q
       (buffer_count[3]));
  nand g5 (n_206, buffer_count[0], buffer_count[1], buffer_count[2],
       buffer_count[3]);
  not g6 (n_82, n_206);
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
