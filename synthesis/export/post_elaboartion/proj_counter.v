
// Generated by Cadence Genus(TM) Synthesis Solution 21.15-s080_1
// Generated on: Aug  6 2024 13:59:21 UTC (Aug  6 2024 13:59:21 UTC)

// Verification Directory fv/proj_counter 

module add_unsigned(A, B, Z);
  input [7:0] A;
  input B;
  output [7:0] Z;
  wire [7:0] A;
  wire B;
  wire [7:0] Z;
  wire n_18, n_22, n_25, n_27, n_31, n_33, n_37, n_39;
  wire n_43, n_44, n_46, n_47, n_49, n_53, n_60, n_62;
  wire n_63, n_64, n_65, n_67, n_72, n_77, n_83, n_86;
  wire n_90;
  xor g1 (Z[0], A[0], B);
  nand g2 (n_18, A[0], B);
  nand g21 (n_25, n_22, A[1]);
  nor g26 (n_47, n_31, n_27);
  nor g30 (n_53, n_37, n_33);
  nand g36 (n_46, n_44, A[2]);
  nand g38 (n_49, n_47, n_44);
  nand g44 (n_64, n_53, A[6]);
  nand g51 (n_62, n_60, A[4]);
  nand g53 (n_63, n_53, n_60);
  not g55 (n_65, n_64);
  nand g56 (n_67, n_60, n_65);
  xnor g62 (Z[1], n_22, n_72);
  xnor g64 (Z[2], n_44, n_31);
  xnor g67 (Z[3], n_77, n_27);
  xnor g69 (Z[4], n_60, n_37);
  xnor g72 (Z[5], n_83, n_33);
  xnor g74 (Z[6], n_86, n_43);
  xnor g77 (Z[7], n_90, n_39);
  not g80 (n_31, A[2]);
  not g81 (n_27, A[3]);
  not g82 (n_37, A[4]);
  not g83 (n_33, A[5]);
  not g84 (n_43, A[6]);
  not g85 (n_39, A[7]);
  not g86 (n_22, n_18);
  not g87 (n_72, A[1]);
  not g88 (n_44, n_25);
  not g89 (n_77, n_46);
  not g90 (n_60, n_49);
  not g91 (n_83, n_62);
  not g92 (n_86, n_63);
  not g93 (n_90, n_67);
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module bmux_1(ctl, in_0, in_1, z);
  input ctl;
  input [7:0] in_0, in_1;
  output [7:0] z;
  wire ctl;
  wire [7:0] in_0, in_1;
  wire [7:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[7]), .data1 (in_1[7]), .z
       (z[7]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[6]), .data1 (in_1[6]), .z
       (z[6]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[5]), .data1 (in_1[5]), .z
       (z[5]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[4]), .data1 (in_1[4]), .z
       (z[4]));
  CDN_bmux2 g5(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g6(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g7(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g8(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module proj_counter(index, finished_count, clk, rst_n);
  input clk, rst_n;
  output [7:0] index;
  output finished_count;
  wire clk, rst_n;
  wire [7:0] index;
  wire finished_count;
  wire [7:0] idx_next;
  wire n_23, n_24, n_25, n_26, n_27, n_28, n_29, n_30;
  wire n_31, n_33, n_62, n_63, n_64, n_65, rst_index;
  add_unsigned add_32_55(.A (index), .B (1'b1), .Z ({n_31, n_30, n_29,
       n_28, n_27, n_26, n_25, n_24}));
  bmux mux_28_38(.ctl (n_23), .in_0 (1'b0), .in_1 (1'b1), .z
       (finished_count));
  bmux_1 mux_32_23(.ctl (finished_count), .in_0 ({n_31, n_30, n_29,
       n_28, n_27, n_26, n_25, n_24}), .in_1 (8'b0), .z (idx_next));
  not g1 (n_33, rst_n);
  or g2 (rst_index, finished_count, n_33);
  CDN_flop \out_index_reg[0] (.clk (clk), .d (idx_next[0]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[0]));
  CDN_flop \out_index_reg[1] (.clk (clk), .d (idx_next[1]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[1]));
  CDN_flop \out_index_reg[2] (.clk (clk), .d (idx_next[2]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[2]));
  CDN_flop \out_index_reg[3] (.clk (clk), .d (idx_next[3]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[3]));
  CDN_flop \out_index_reg[4] (.clk (clk), .d (idx_next[4]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[4]));
  CDN_flop \out_index_reg[5] (.clk (clk), .d (idx_next[5]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[5]));
  CDN_flop \out_index_reg[6] (.clk (clk), .d (idx_next[6]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[6]));
  CDN_flop \out_index_reg[7] (.clk (clk), .d (idx_next[7]), .sena
       (1'b1), .aclr (1'b0), .apre (1'b0), .srl (rst_index), .srd
       (1'b0), .q (index[7]));
  nor g9 (n_62, index[7], index[6], index[5], index[4]);
  not g10 (n_63, index[3]);
  nand g11 (n_64, n_63, index[0], index[1], index[2]);
  not g12 (n_65, n_62);
  nor g13 (n_23, n_64, n_65);
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
